% Copyright (C) 2014-2023 by Thomas Auzinger <thomas@auzinger.name>

% TODO: remove draft
\documentclass[draft,final]{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage[inline]{enumitem} % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesetting of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{todonotes} % Provides tooltip-like todo notes.
\usepackage{hyperref}  % Enables hyperlinking in the electronic document version. This package has to be included second to last.
\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists of acronyms. This package has to be included last.

% custom packages
\usepackage{threeparttable}


% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Othmar Lechner} % The author name without titles.
\newcommand{\thesistitle}{T-RACE: Tracing race condition attacks between Ethereum transactions.} % The title of the thesis. The English version should be used, if it exists.

% Set PDF document properties
\hypersetup{
    pdfpagelayout   = TwoPageRight,           % How the document is shown in PDF viewers (optional).
    linkbordercolor = {Melon},                % The color of the borders of boxes around hyperlinks (optional).
    pdfauthor       = {\authorname},          % The author's name in the document properties (optional).
    pdftitle        = {\thesistitle},         % The document's title in the document properties (optional).
    pdfsubject      = {Subject},              % The document's subject in the document properties (optional).
    pdfkeywords     = {a, list, of, keywords} % The document's keywords in the document properties (optional).
}

\setpnumwidth{2.5em}        % Avoid overfull hboxes in the table of contents (see memoir manual).
\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph indentation (optional).

\makeindex      % Use an optional index.
\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Pretitle}{Forename Surname}{Posttitle}{male}

% For bachelor and master theses:
\setfirstassistant{Pretitle}{Forename Surname}{Posttitle}{male}
\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

% For dissertations:
\setfirstreviewer{Pretitle}{Forename Surname}{Posttitle}{male}
\setsecondreviewer{Pretitle}{Forename Surname}{Posttitle}{male}

% For dissertations at the PhD School and optionally for dissertations:
\setsecondadvisor{Pretitle}{Forename Surname}{Posttitle}{male} % Comment to remove.

% Required data.
\setregnumber{11841833}
\setdate{01}{01}{2001} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{T-RACE: Eine Analyse von race condition Angriffen bei Ethereum Transaktionen} % Sets English and German version of the title (both can be English or German). If your title contains commas, enclose it with additional curvy brackets (i.e., {{your title}}) or define it as a macro as done with \thesistitle.
% \setsubtitle{Optional Subtitle of the Thesis}{Optionaler Untertitel der Arbeit} % Sets English and German version of the subtitle (both can be English or German).

% Select the thesis type: bachelor / master / doctor.
% Bachelor:
% \setthesis{bachelor}
%
% Master:
\setthesis{master}
% TODO: dipl. or master?
\setmasterdegree{dipl.} % dipl. / rer.nat. / rer.soc.oec. / master
%
% Doctor:
%\setthesis{doctor}
%\setdoctordegree{rer.soc.oec.}% rer.nat. / techn. / rer.soc.oec.

% For bachelor and master:
\setcurriculum{Software Engineering \& Internet Computing}{Software Engineering \& Internet Computing} % Sets the English and German name of the curriculum.

% Optional reviewer data:
\setfirstreviewerdata{Affiliation, Country}
\setsecondreviewerdata{Affiliation, Country}


\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to the guidelines at
%  https://informatics.tuwien.ac.at/study-services

\addtitlepage{naustrian} % German title page.
\addtitlepage{english} % English title page.
\addstatementpage

\begin{danksagung*}
\todo{Ihr Text hier.}
\end{danksagung*}

\begin{acknowledgements*}
\todo{Enter your text here.}
\end{acknowledgements*}

\begin{kurzfassung}
\todo{Ihr Text hier.}
\end{kurzfassung}

\begin{abstract}
\todo{Enter your text here.}
\end{abstract}

% Select the language of the thesis, e.g., english or naustrian.
\selectlanguage{english}

% Add a table of contents (toc).
\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}
\todo{Enter your text here.}

\section{Ethereum}

\section{Frontrunning}

\section{Related work}

Interesting things:
- name
- source is available?
- does it use RPC / instrumentation / native tracing?
- does it detect some kind of frontrunning

See table \ref{tab:blockchain_history_analyzers}.


\begin{table}[h]
    \begin{center}
        \begin{tabular}{ | l | c  | c | c | c | }
            \hline
            Tool/Authors & Scope \\ \hline
            EthScope \cite{wu_time-travel_2022} & Generalized \\ \hline
            TokenScope \cite{chen_tokenscope_2019} & ERC-20 tokens \\ \hline
            TXSPECTOR \cite{zhang_txspector_2020} & Generalized \\ \hline
            Horus \cite{ferreira_torres_eye_2021} & Generalized \\ \hline
            SODA \cite{chen_soda_2020} &  Generalized \\ \hline
            DEFIER \cite{su_evil_2021} & Generalized \\ \hline
            Zhou et al. \cite{zhou_ever-evolving_2020} & Generalized \\ \hline
            Perez et al. \cite{perez_smart_2021} & Generalized \\ \hline
            Wang et al. \cite{wang_impact_2022} & Sandwich attacks \\ \hline
            Erebus-Redgiant \cite{zhang_combatting_2023} & Frontrunning \\ \hline
            Frontrunner Jones \cite{torres_frontrunner_2021} & Frontrunning \\ \hline
        \end{tabular}
        \caption{Blockchain history analysis references. Generalized means, that the data collection and analysis framework is not tailored to specific vulnerabilities.}
        \label{tab:blockchain_history_analyzers}
    \end{center}
\end{table}
\todo{better caption}

\chapter{Frontrunning definitions}

\todo{Is it important to differentiate between sandwich attacks and displacement attacks?}
\todo{Should we go from first source to last sink? eg in a swap call, we will have multiple LOG events at different levels.}

\section{TOD sources}

For $T_A \rightarrow T_B$:

\begin{enumerate}
    \item TOD write point: point, where $T_A$ modifies some state, that is read by $T_B$
    \item TOD read point: point, where $T_B$ reads some state, that was modified by $T_A$
    \item TOD hidden write point: point, where $T_A$ modifies some state, that is overwritten by $T_B$
    \item TOD overwrite point: point, where $T_B$ overwrites some state, that was written by $T_A$
\end{enumerate}

The pair of (TOD write point, TOD read point) presents a write-read conflict. The pair of (TOD hidden write point, TOD overwrite point) presents a write-write conflict.

If we have a write-read conflict and a write-write conflict, $T_B$ reads some state and then overwrites it. Thus, $T_B$ knows of the modified state before overwriting.

One instance would be a simple counter, where both $T_A$ and $T_B$ increment the same counter in the state. Here, we would have a write-read conflict, as $T_B$ reads the counter incremented by $T_A$. And further, we would have a write-write conflict, as $T_B$ updates the same counter as $T_A$.

ERC-20 approval attack would consist of the hidden write point (where approval is set to 0) and an overwrite point (where approval is set to some higher value).

ERC-20 approval migitation (with require for the prev value) would consist of a write point (where approval is set to 0) and a read point (where the approval is used for the require statement).

Uniswap token swap would consist of both a write-read conflict and a write-write conflict. The write-read conflict exists, as $T_A$ modifies the reserves state and $T_B$ reads the current reserves to calculate a price. The write-write conflict exists, as $T_A$ modifies the reserves state and $T_B$ modifies it as well. Contrary to ERC-20 approval, the overwritten value depends on the previous value (which we could show in the data flow graph).

\subsection{State reading instructions}

The EVM uses the nonce to check if an account already exists. For CALL, CALLCODE and SELFDESTRUCT, this is used to calculate the gas costs. For CREATE and CREATE2, this is used to prevent creating an account at an already active address.

See table \ref{tab:state_reading_instructions}.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{ | l | c  | c | c | c | }
            \hline
            Instruction     & Storage   & Balance       & Code          & Nonce \\ \hline
            SLOAD &         \checkmark  &               &               & \\  \hline
            BALANCE &                   & \checkmark    &               & \\ \hline
            SELFBALANCE &               & \checkmark    &               & \\ \hline
            CODESIZE &                  &               & \checkmark    & \\ \hline
            CODECOPY &                  &               & \checkmark    & \\ \hline
            EXTCODECOPY &               &               & \checkmark    & \\ \hline
            EXTCODESIZE &               &               & \checkmark    & \\ \hline
            EXTCODEHASH &               &               & \checkmark    & \\ \hline
            CALL &                      & \checkmark    & \checkmark    & \checkmark \\ \hline
            CALLCODE &                  & \checkmark    & \checkmark    & \checkmark \\ \hline
            STATICCALL &                &               & \checkmark    & \\ \hline
            DELEGATECALL &              &               & \checkmark    & \\ \hline
            CREATE &                    & \checkmark    & \checkmark    & \checkmark \\ \hline
            CREATE2 &                   & \checkmark    & \checkmark    & \checkmark \\ \hline
            SELFDESTRUCT &              & \checkmark    & \checkmark    & \checkmark \\ \hline
        \end{tabular}
        \caption{Instructions that access state. A checkmark indicates, that the execution of this instruction can depend on this state type.}
        \label{tab:state_reading_instructions}
    \end{center}
\end{table}

\subsection{State writing instructions}

See table \ref{tab:state_writing_instructions}.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{ | l | c  | c | c | c | }
            \hline
            Instruction     & Storage   & Balance       & Code          & Nonce \\ \hline
            SSTORE &        \checkmark  &               &               & \\ \hline
            CALL &                      & \checkmark    &               & \\ \hline
            CALLCODE &                  & \checkmark    &               & \\ \hline
            STATICCALL &                &               &               & \\ \hline
            DELEGATECALL &              &               &               & \\ \hline
            CREATE &                    & \checkmark    & \checkmark    & \checkmark \\ \hline
            CREATE2 &                   & \checkmark    & \checkmark    & \checkmark \\ \hline
            SELFDESTRUCT &  \checkmark  & \checkmark    & \checkmark    & \checkmark \\ \hline
        \end{tabular}
        \caption{Instructions that modify state. A checkmark indicates, that the execution of this instruction can modify this state type.}
        \label{tab:state_writing_instructions}
    \end{center}
\end{table}

Nonce is also incremented by EOA calls.

\section{TOD sinks}

\section{TOD sanitizers}

\chapter{TOD attack mining}


% NOTE: the mined attacks won't be representative of all contracts
%'s favored towards attacked contracts, and to frequently-used contracts

\section{Related approaches}

\subsection{Combatting paper - Erebus-redgiant}

How do they replay potential attack/victim transactions?

Their framework allows to fork at a specific block and tx\_index.

PrepareStateAndContext - replays up to tx index.


They skip potential victim transactions if:

\begin{enumerate}
    \item error victim transactions (\todo{Are these failed transactions in Ethereum, or error somewhere in their framework? If it's the first, why???})
    \item "filtered" transactions \todo{What are these?}
    \item unverified contracts in victim transactions
    \item victim tx is contract creation (why???). But a good label :)
    \item victim tx is ether transfer
    \item no overlap with attack tx (compare sets of contracts/accounts)
    \item no dependency (storage and balance dependencies, but seem to ignore dependencies within reverted calls)
\end{enumerate}

Replaying in the attack free scenario:

\begin{enumerate}
    \item take attack tx state (I guess prestate)
    \item take victim context (I guess block environment, timestamp, ...)
    \item apply "prerequesites" - all previous transactions from the same sender within (attack, victim-1)?
    \item apply + trace victim tx
    \item apply + trace attack tx
\end{enumerate}

For prerequesites, refer to \href{https://github.com/Troublor/erebus-redgiant/blob/4544163f0c6a369b35c3237851f482d240fa7bbd/dataset/tx_history_test.go#L42-L53}.

Problems with this approach:

\begin{enumerate}
    \item prerequesites is an arbitrary choice
    \subitem what if prerequesites have collisions with the attack?
    \subitem what if prerequesites depend on other transactions that were not replayed?
    \subitem what if victim tx depends on other transactions that were not replayed?
    \item all transactions share the same context
    \subitem attack tx is moved to different context
    \subitem prerequesites are potentially moved to different context
    \subitem (victim tx stays in same context \checkmark)
    \item replay is done with a different environment
\end{enumerate}


\section{TOD candidate finding}

\subsection{Prestates}

Inclusion criteria.

\section{TOD candidate filtering}

\subsection{Attack prerequesites}

Exclusion criteria:

\begin{enumerate}
    \item $Tx_A$ is from the same sender as $Tx_B$.
    \item $Tx_B$ is only an Ether transfer.
\end{enumerate}

\subsection{Deduplication}

We want a diverse set of attacks for the benchmark, so we filter out similar attacks to the ones we already analyzed. For instance, it does not make sense to analyze 5000 attacks for the USDT Stablecoin, as these will mostly collide.

If possible, we don't need the traces analyzer for deduplication. For instance, maybe we can get all the necessary information from the default RPC tracers.
Alternatively, we could also download all necessary data, and then loop through the traces analyzer and only pick the relevant (deduplicated) potential attacks.

Ideas, potentially a mixture of those:

\begin{enumerate}
    \item only trace some attacks per contract
    \item only trace some attacks per function
    \item only trace some attacks per group of vulnerable contracts (as defined by analysis)
    \item only trace some attacks per contract/function skeletons
    \item similar to \cite{}, analyze at how many attacks per contract/function the number of found attacks saturate (based on the analysis result)
\end{enumerate}

\chapter{Trace analysis}

\section{Trace replaying}

\subsection{RPC methods}


\todo{\href{https://github.com/paradigmxyz/reth/issues/8202}{Prestate tracer currently does not include prestate for reverted call contexts}}
\todo{Use quicknode RPC to compare stateDiff/prestate traces from our Reth with their Erigon instance.}

\subsubsection{trace\_call}


Takes:
\begin{enumerate}
    \item tx info
    \item block number/hash
    \item multiple trace types (Trace, VmTrace, StateDiff)
    \item state overrides (storage, code, ...) - Use stateDiff!
    \item block overrides (number, hash, timestamp, ...)
\end{enumerate}

No replaying of previous transactions in the same block, thus we would need to use the state overrides for this effect (calculate state overrides offline, based on stateDiffs from all transactions).

\subsubsection{debug\_traceCall}

Takes:
\begin{enumerate}
    \item tx info
    \item block number/hash
    \item multiple trace types via mux (4byte, call tracer, prestate/diffstate, JS)
    \item state overrides (storage, code, ...) - Use stateDiff!
    \item block overrides
\end{enumerate}

No replaying of previous transactions in the same block, thus we would need to use the state overrides for this effect (calculate state overrides offline, based on stateDiffs from all transactions).

No opcode tracer in reth?

\subsection{Algorithm}

Lets say, we have a transaction $T_A$ and a $T_B$, where $T_A$ occurred in block $Block_A$ and $T_B$ occurred in $Block_B$ (which may be equal to $Block_A$). Further, $T_A$ occurred before $T_B$, denoted as $T_A \rightarrow T_B$.

We want to replay following scenarios:

\begin{enumerate}
    \item actual: $T_A \rightarrow T_B$
    \item reverse: $T_B \rightarrow T_A$
\end{enumerate}

\subsubsection{Actual: $T_A \rightarrow T_B$}
In the actual scenario, we replay what actually happened on the blockchain. The observed behaviour should be identical to the one recorded on the blockchain.

To replay $T_A$, we take the environment from $Block_A$ and the state $S_{base}$ before any transaction was executed in $Block_A$. Then, we go through all transactions that happened in $Block_A$ before $T_A$ and add their state changes to $S_{base}$. We end up with $S = S_{base} + \sum_{i=0}^{i=index(T_A)}SD_{T_i}$.

We then execute $T_A$ in the environment from $Block_A$ and with the state $S$ and record its trace.

The replaying of $T_B$ is analogous, by using the environment from $Block_B$ and a state that is built based on $Block_B$ and all transactions prior to $T_B$.

\subsubsection{Reverse: $T_B \rightarrow T_A$}

In the reverse scenario, we want to understand, what would have happend if they were executed the other way around. We model the executions state and environment identical to the actual scenario, except for the state impacts by $T_B$ and $T_A$. If we would have differences in the state or environment model, they could influence the transaction and hinder the focused analysis of the TOD.

To simulate $T_B$ before $T_A$, we execute $T_B$ as in the actual scenario. However, as a state we use $S\prime = S - SD_{T_A}$, ie we remove the changes by $T_A$ from the state.

To simulate $T_A$ after $T_B$, we execute $T_A$ as in the actual scenario. However, as a state we use $S\prime = S + SD_{T_B}$\todo{We should add the result from executing $T_B$ before $T_A$, not the actual result (from executing $T_B$ after $T_A$)}, ie we add the changes by $T_B$ on top of the state.

In both cases, the only difference for the execution, is the modification with the other transactions state. Thus, only this state modification can impact a change of the execution, which is exactly what we want to simulate the TOD.

Compared to other methods, this state overriding method does not struggle with changed environments if we move transactions between blocks and changed states if we move transactions to other positions within blocks.

However, it could be "unrealistic", if there is some transaction $T_A \rightarrow T_C \rightarrow T_B$ where $T_C$ also depends on state modifications done by $T_A$. In such a scenario, moving $T_A$ after $T_B$ would in reality also impact $T_C$ which directly or indirectly could also impact $T_A$ and $T_B$. We can prevent this, if we only analyze pairs of transactions where there is no such intermediate transaction. For instance, in this case we could analyze $T_A \rightarrow T_C$ and $T_C \rightarrow T_B$ in isolation.

\begin{verbatim}
contract IntermediateDependencyExample {
    function setX(x) {
        self.x = x;
    }
    function setXIfGreater(x, threshold) {
        if (self.x > threshold) {
            self.x = x
        }
    }
    function readX() {
        return self.x
    }
}
\end{verbatim}

\begin{verbatim}
Scenario 1:

// this could also only be partial
// eg if A sets X and Y, and C only sets Y
// x = 0
Tx A: setX(1) // x = 1
Tx C: setX(2) // x = 2
Tx B: readX() // -> 2

Scenario 2:
// x = 0
Tx A: setX(20) // x = 20
Tx C: setXIfGreater(30, 10) // x = 30
Tx B: readX()  // -> 30
\end{verbatim}

In scenario 2, if we would execute $T_A$ after $T_B$, the $setXIfGreater$ call by $T_C$ would also behave differently in reality. $T_B$ would return $0$, however this is the result of $T_A$ and $T_C$ acting together. Thus, we canont analyze the pair $(T_A, T_B)$ in isolation, as it depends on $T_C$. However, we could analyze $(T_A, T_C)$ and $(T_C, T_B)$ separately.

\section{Trace parsing}

Features:

\begin{enumerate}
    \item parses executed instructions with inputs and outputs
    \item handles internal transactions, including normal and exceptional halts
    \item tracks data origin for each byte of data, across calls and storages
    \item uses reference for DUPn instructions (so verification on one duplicate also verifies the other duplicate)
    \item outputs data flow graph, eg for source-sanitizers-sink analysis (and sanitizers could occur after sinks in Ethereum, because of reverts)
\end{enumerate}

Using traces instead of a full-fledged EVM allows:

\begin{enumerate}
    \item easier extension, as for instructions we only need to model their data flow
    \item interoperability with all nodes and other tools that produce traces
    \item automatic verification of the modelled data flows against the actual stack and memory
\end{enumerate}

\section{Attack categorization}

\section{Vulnerability localization}

\section{Attack labeling}

\chapter{TOD Attack results}

Findings of the TOD attack mining and analysis.

\chapter{Tool benchmarking}

\section{Systematic Literature Review}

\section{Setup}

\section{Result}



% \input{intro.tex} % A short introduction to LaTeX.

\backmatter

% Use an optional list of figures.
\listoffigures % Starred version, i.e., \listoffigures*, removes the toc entry.

% Use an optional list of tables.
\cleardoublepage % Start list of tables on the next empty right hand page.
\listoftables % Starred version, i.e., \listoftables*, removes the toc entry.

% Use an optional list of alogrithms.
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Add an index.
\printindex

% Add a glossary.
\printglossaries

% Add a bibliography.
\bibliographystyle{alpha}
\bibliography{references}

\end{document}